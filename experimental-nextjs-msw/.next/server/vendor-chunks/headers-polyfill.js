"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/headers-polyfill";
exports.ids = ["vendor-chunks/headers-polyfill"];
exports.modules = {

/***/ "(rsc)/./node_modules/headers-polyfill/lib/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/headers-polyfill/lib/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   flattenHeadersList: () => (/* binding */ flattenHeadersList),\n/* harmony export */   flattenHeadersObject: () => (/* binding */ flattenHeadersObject),\n/* harmony export */   getRawHeaders: () => (/* binding */ getRawHeaders),\n/* harmony export */   headersToList: () => (/* binding */ headersToList),\n/* harmony export */   headersToObject: () => (/* binding */ headersToObject),\n/* harmony export */   headersToString: () => (/* binding */ headersToString),\n/* harmony export */   listToHeaders: () => (/* binding */ listToHeaders),\n/* harmony export */   objectToHeaders: () => (/* binding */ objectToHeaders),\n/* harmony export */   reduceHeadersObject: () => (/* binding */ reduceHeadersObject),\n/* harmony export */   stringToHeaders: () => (/* binding */ stringToHeaders)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function __require() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n// node_modules/set-cookie-parser/lib/set-cookie.js\nvar require_set_cookie = __commonJS({\n    \"node_modules/set-cookie-parser/lib/set-cookie.js\" (exports, module) {\n        \"use strict\";\n        var defaultParseOptions = {\n            decodeValues: true,\n            map: false,\n            silent: false\n        };\n        function isNonEmptyString(str) {\n            return typeof str === \"string\" && !!str.trim();\n        }\n        function parseString(setCookieValue, options) {\n            var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n            var nameValuePairStr = parts.shift();\n            var parsed = parseNameValuePair(nameValuePairStr);\n            var name = parsed.name;\n            var value = parsed.value;\n            options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n            try {\n                value = options.decodeValues ? decodeURIComponent(value) : value;\n            } catch (e) {\n                console.error(\"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\", e);\n            }\n            var cookie = {\n                name,\n                value\n            };\n            parts.forEach(function(part) {\n                var sides = part.split(\"=\");\n                var key = sides.shift().trimLeft().toLowerCase();\n                var value2 = sides.join(\"=\");\n                if (key === \"expires\") {\n                    cookie.expires = new Date(value2);\n                } else if (key === \"max-age\") {\n                    cookie.maxAge = parseInt(value2, 10);\n                } else if (key === \"secure\") {\n                    cookie.secure = true;\n                } else if (key === \"httponly\") {\n                    cookie.httpOnly = true;\n                } else if (key === \"samesite\") {\n                    cookie.sameSite = value2;\n                } else {\n                    cookie[key] = value2;\n                }\n            });\n            return cookie;\n        }\n        function parseNameValuePair(nameValuePairStr) {\n            var name = \"\";\n            var value = \"\";\n            var nameValueArr = nameValuePairStr.split(\"=\");\n            if (nameValueArr.length > 1) {\n                name = nameValueArr.shift();\n                value = nameValueArr.join(\"=\");\n            } else {\n                value = nameValuePairStr;\n            }\n            return {\n                name,\n                value\n            };\n        }\n        function parse(input, options) {\n            options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n            if (!input) {\n                if (!options.map) {\n                    return [];\n                } else {\n                    return {};\n                }\n            }\n            if (input.headers) {\n                if (typeof input.headers.getSetCookie === \"function\") {\n                    input = input.headers.getSetCookie();\n                } else if (input.headers[\"set-cookie\"]) {\n                    input = input.headers[\"set-cookie\"];\n                } else {\n                    var sch = input.headers[Object.keys(input.headers).find(function(key) {\n                        return key.toLowerCase() === \"set-cookie\";\n                    })];\n                    if (!sch && input.headers.cookie && !options.silent) {\n                        console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n                    }\n                    input = sch;\n                }\n            }\n            if (!Array.isArray(input)) {\n                input = [\n                    input\n                ];\n            }\n            options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n            if (!options.map) {\n                return input.filter(isNonEmptyString).map(function(str) {\n                    return parseString(str, options);\n                });\n            } else {\n                var cookies = {};\n                return input.filter(isNonEmptyString).reduce(function(cookies2, str) {\n                    var cookie = parseString(str, options);\n                    cookies2[cookie.name] = cookie;\n                    return cookies2;\n                }, cookies);\n            }\n        }\n        function splitCookiesString2(cookiesString) {\n            if (Array.isArray(cookiesString)) {\n                return cookiesString;\n            }\n            if (typeof cookiesString !== \"string\") {\n                return [];\n            }\n            var cookiesStrings = [];\n            var pos = 0;\n            var start;\n            var ch;\n            var lastComma;\n            var nextStart;\n            var cookiesSeparatorFound;\n            function skipWhitespace() {\n                while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\n                    pos += 1;\n                }\n                return pos < cookiesString.length;\n            }\n            function notSpecialChar() {\n                ch = cookiesString.charAt(pos);\n                return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n            }\n            while(pos < cookiesString.length){\n                start = pos;\n                cookiesSeparatorFound = false;\n                while(skipWhitespace()){\n                    ch = cookiesString.charAt(pos);\n                    if (ch === \",\") {\n                        lastComma = pos;\n                        pos += 1;\n                        skipWhitespace();\n                        nextStart = pos;\n                        while(pos < cookiesString.length && notSpecialChar()){\n                            pos += 1;\n                        }\n                        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n                            cookiesSeparatorFound = true;\n                            pos = nextStart;\n                            cookiesStrings.push(cookiesString.substring(start, lastComma));\n                            start = pos;\n                        } else {\n                            pos = lastComma + 1;\n                        }\n                    } else {\n                        pos += 1;\n                    }\n                }\n                if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n                    cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n                }\n            }\n            return cookiesStrings;\n        }\n        module.exports = parse;\n        module.exports.parse = parse;\n        module.exports.parseString = parseString;\n        module.exports.splitCookiesString = splitCookiesString2;\n    }\n});\n// src/Headers.ts\nvar import_set_cookie_parser = __toESM(require_set_cookie());\n// src/utils/normalizeHeaderName.ts\nvar HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i;\nfunction normalizeHeaderName(name) {\n    if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === \"\") {\n        throw new TypeError(\"Invalid character in header field name\");\n    }\n    return name.trim().toLowerCase();\n}\n// src/utils/normalizeHeaderValue.ts\nvar charCodesToRemove = [\n    String.fromCharCode(10),\n    String.fromCharCode(13),\n    String.fromCharCode(9),\n    String.fromCharCode(32)\n];\nvar HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join(\"\")}]|$[${charCodesToRemove.join(\"\")}])`, \"g\");\nfunction normalizeHeaderValue(value) {\n    const nextValue = value.replace(HEADER_VALUE_REMOVE_REGEXP, \"\");\n    return nextValue;\n}\n// src/utils/isValidHeaderName.ts\nfunction isValidHeaderName(value) {\n    if (typeof value !== \"string\") {\n        return false;\n    }\n    if (value.length === 0) {\n        return false;\n    }\n    for(let i = 0; i < value.length; i++){\n        const character = value.charCodeAt(i);\n        if (character > 127 || !isToken(character)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isToken(value) {\n    return ![\n        127,\n        32,\n        \"(\",\n        \")\",\n        \"<\",\n        \">\",\n        \"@\",\n        \",\",\n        \";\",\n        \":\",\n        \"\\\\\",\n        '\"',\n        \"/\",\n        \"[\",\n        \"]\",\n        \"?\",\n        \"=\",\n        \"{\",\n        \"}\"\n    ].includes(value);\n}\n// src/utils/isValidHeaderValue.ts\nfunction isValidHeaderValue(value) {\n    if (typeof value !== \"string\") {\n        return false;\n    }\n    if (value.trim() !== value) {\n        return false;\n    }\n    for(let i = 0; i < value.length; i++){\n        const character = value.charCodeAt(i);\n        if (// NUL.\n        character === 0 || // HTTP newline bytes.\n        character === 10 || character === 13) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/Headers.ts\nvar NORMALIZED_HEADERS = Symbol(\"normalizedHeaders\");\nvar RAW_HEADER_NAMES = Symbol(\"rawHeaderNames\");\nvar HEADER_VALUE_DELIMITER = \", \";\nvar _a, _b;\nvar Headers = class _Headers {\n    constructor(init){\n        // Normalized header {\"name\":\"a, b\"} storage.\n        this[_a] = {};\n        // Keeps the mapping between the raw header name\n        // and the normalized header name to ease the lookup.\n        this[_b] = /* @__PURE__ */ new Map();\n        if ([\n            \"Headers\",\n            \"HeadersPolyfill\"\n        ].includes(init?.constructor.name) || init instanceof _Headers || typeof globalThis.Headers !== \"undefined\" && init instanceof globalThis.Headers) {\n            const initialHeaders = init;\n            initialHeaders.forEach((value, name)=>{\n                this.append(name, value);\n            }, this);\n        } else if (Array.isArray(init)) {\n            init.forEach(([name, value])=>{\n                this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);\n            });\n        } else if (init) {\n            Object.getOwnPropertyNames(init).forEach((name)=>{\n                const value = init[name];\n                this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);\n            });\n        }\n    }\n    [(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, Symbol.iterator)]() {\n        return this.entries();\n    }\n    *keys() {\n        for (const [name] of this.entries()){\n            yield name;\n        }\n    }\n    *values() {\n        for (const [, value] of this.entries()){\n            yield value;\n        }\n    }\n    *entries() {\n        let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b)=>a.localeCompare(b));\n        for (const name of sortedKeys){\n            if (name === \"set-cookie\") {\n                for (const value of this.getSetCookie()){\n                    yield [\n                        name,\n                        value\n                    ];\n                }\n            } else {\n                yield [\n                    name,\n                    this.get(name)\n                ];\n            }\n        }\n    }\n    /**\n   * Returns a boolean stating whether a `Headers` object contains a certain header.\n   */ has(name) {\n        if (!isValidHeaderName(name)) {\n            throw new TypeError(`Invalid header name \"${name}\"`);\n        }\n        return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));\n    }\n    /**\n   * Returns a `ByteString` sequence of all the values of a header with a given name.\n   */ get(name) {\n        if (!isValidHeaderName(name)) {\n            throw TypeError(`Invalid header name \"${name}\"`);\n        }\n        return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;\n    }\n    /**\n   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */ set(name, value) {\n        if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n            return;\n        }\n        const normalizedName = normalizeHeaderName(name);\n        const normalizedValue = normalizeHeaderValue(value);\n        this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);\n        this[RAW_HEADER_NAMES].set(normalizedName, name);\n    }\n    /**\n   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */ append(name, value) {\n        if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n            return;\n        }\n        const normalizedName = normalizeHeaderName(name);\n        const normalizedValue = normalizeHeaderValue(value);\n        let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;\n        this.set(name, resolvedValue);\n    }\n    /**\n   * Deletes a header from the `Headers` object.\n   */ delete(name) {\n        if (!isValidHeaderName(name)) {\n            return;\n        }\n        if (!this.has(name)) {\n            return;\n        }\n        const normalizedName = normalizeHeaderName(name);\n        delete this[NORMALIZED_HEADERS][normalizedName];\n        this[RAW_HEADER_NAMES].delete(normalizedName);\n    }\n    /**\n   * Traverses the `Headers` object,\n   * calling the given callback for each header.\n   */ forEach(callback, thisArg) {\n        for (const [name, value] of this.entries()){\n            callback.call(thisArg, value, name, this);\n        }\n    }\n    /**\n   * Returns an array containing the values\n   * of all Set-Cookie headers associated\n   * with a response\n   */ getSetCookie() {\n        const setCookieHeader = this.get(\"set-cookie\");\n        if (setCookieHeader === null) {\n            return [];\n        }\n        if (setCookieHeader === \"\") {\n            return [\n                \"\"\n            ];\n        }\n        return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);\n    }\n};\n// src/getRawHeaders.ts\nfunction getRawHeaders(headers) {\n    const rawHeaders = {};\n    for (const [name, value] of headers.entries()){\n        rawHeaders[headers[RAW_HEADER_NAMES].get(name)] = value;\n    }\n    return rawHeaders;\n}\n// src/transformers/headersToList.ts\nfunction headersToList(headers) {\n    const headersList = [];\n    headers.forEach((value, name)=>{\n        const resolvedValue = value.includes(\",\") ? value.split(\",\").map((value2)=>value2.trim()) : value;\n        headersList.push([\n            name,\n            resolvedValue\n        ]);\n    });\n    return headersList;\n}\n// src/transformers/headersToString.ts\nfunction headersToString(headers) {\n    const list = headersToList(headers);\n    const lines = list.map(([name, value])=>{\n        const values = [].concat(value);\n        return `${name}: ${values.join(\", \")}`;\n    });\n    return lines.join(\"\\r\\n\");\n}\n// src/transformers/headersToObject.ts\nvar singleValueHeaders = [\n    \"user-agent\"\n];\nfunction headersToObject(headers) {\n    const headersObject = {};\n    headers.forEach((value, name)=>{\n        const isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(\",\");\n        headersObject[name] = isMultiValue ? value.split(\",\").map((s)=>s.trim()) : value;\n    });\n    return headersObject;\n}\n// src/transformers/stringToHeaders.ts\nfunction stringToHeaders(str) {\n    const lines = str.trim().split(/[\\r\\n]+/);\n    return lines.reduce((headers, line)=>{\n        if (line.trim() === \"\") {\n            return headers;\n        }\n        const parts = line.split(\": \");\n        const name = parts.shift();\n        const value = parts.join(\": \");\n        headers.append(name, value);\n        return headers;\n    }, new Headers());\n}\n// src/transformers/listToHeaders.ts\nfunction listToHeaders(list) {\n    const headers = new Headers();\n    list.forEach(([name, value])=>{\n        const values = [].concat(value);\n        values.forEach((value2)=>{\n            headers.append(name, value2);\n        });\n    });\n    return headers;\n}\n// src/transformers/reduceHeadersObject.ts\nfunction reduceHeadersObject(headers, reducer, initialState) {\n    return Object.keys(headers).reduce((nextHeaders, name)=>{\n        return reducer(nextHeaders, name, headers[name]);\n    }, initialState);\n}\n// src/transformers/objectToHeaders.ts\nfunction objectToHeaders(headersObject) {\n    return reduceHeadersObject(headersObject, (headers, name, value)=>{\n        const values = [].concat(value).filter(Boolean);\n        values.forEach((value2)=>{\n            headers.append(name, value2);\n        });\n        return headers;\n    }, new Headers());\n}\n// src/transformers/flattenHeadersList.ts\nfunction flattenHeadersList(list) {\n    return list.map(([name, values])=>{\n        return [\n            name,\n            [].concat(values).join(\", \")\n        ];\n    });\n}\n// src/transformers/flattenHeadersObject.ts\nfunction flattenHeadersObject(headersObject) {\n    return reduceHeadersObject(headersObject, (headers, name, value)=>{\n        headers[name] = [].concat(value).join(\", \");\n        return headers;\n    }, {});\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGVhZGVycy1wb2x5ZmlsbC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsV0FBV0MsT0FBT0MsTUFBTTtBQUM1QixJQUFJQyxZQUFZRixPQUFPRyxjQUFjO0FBQ3JDLElBQUlDLG1CQUFtQkosT0FBT0ssd0JBQXdCO0FBQ3RELElBQUlDLG9CQUFvQk4sT0FBT08sbUJBQW1CO0FBQ2xELElBQUlDLGVBQWVSLE9BQU9TLGNBQWM7QUFDeEMsSUFBSUMsZUFBZVYsT0FBT1csU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLGFBQWEsQ0FBQ0MsSUFBSUMsTUFBUSxTQUFTQztRQUNyQyxPQUFPRCxPQUFPLENBQUMsR0FBR0QsRUFBRSxDQUFDUixrQkFBa0JRLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDQyxNQUFNO1lBQUVFLFNBQVMsQ0FBQztRQUFFLEdBQUdBLE9BQU8sRUFBRUYsTUFBTUEsSUFBSUUsT0FBTztJQUNwRztBQUNBLElBQUlDLGNBQWMsQ0FBQ0MsSUFBSUMsTUFBTUMsUUFBUUM7SUFDbkMsSUFBSUYsUUFBUSxPQUFPQSxTQUFTLFlBQVksT0FBT0EsU0FBUyxZQUFZO1FBQ2xFLEtBQUssSUFBSUcsT0FBT2pCLGtCQUFrQmMsTUFDaEMsSUFBSSxDQUFDVixhQUFhYyxJQUFJLENBQUNMLElBQUlJLFFBQVFBLFFBQVFGLFFBQ3pDbkIsVUFBVWlCLElBQUlJLEtBQUs7WUFBRUUsS0FBSyxJQUFNTCxJQUFJLENBQUNHLElBQUk7WUFBRUcsWUFBWSxDQUFFSixDQUFBQSxPQUFPbEIsaUJBQWlCZ0IsTUFBTUcsSUFBRyxLQUFNRCxLQUFLSSxVQUFVO1FBQUM7SUFDdEg7SUFDQSxPQUFPUDtBQUNUO0FBQ0EsSUFBSVEsVUFBVSxDQUFDWixLQUFLYSxZQUFZQyxTQUFZQSxDQUFBQSxTQUFTZCxPQUFPLE9BQU9oQixTQUFTUyxhQUFhTyxRQUFRLENBQUMsR0FBR0csWUFDbkcs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QUNMTixlQUNBLENBQUN2RixTQUFTekIsTUFBTXBCO1FBQ2Q2QyxPQUFPLENBQUN6QixLQUFLLEdBQUcsRUFBRSxDQUFDNkcsTUFBTSxDQUFDakksT0FBT2lDLElBQUksQ0FBQztRQUN0QyxPQUFPWTtJQUNULEdBQ0EsQ0FBQztBQUVMO0FBYUUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtbXN3Ly4vbm9kZV9tb2R1bGVzL2hlYWRlcnMtcG9seWZpbGwvbGliL2luZGV4Lm1qcz84ZjI2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qc1xudmFyIHJlcXVpcmVfc2V0X2Nvb2tpZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICAgICAgZGVjb2RlVmFsdWVzOiB0cnVlLFxuICAgICAgbWFwOiBmYWxzZSxcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoc3RyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFydHMgPSBzZXRDb29raWVWYWx1ZS5zcGxpdChcIjtcIikuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpO1xuICAgICAgdmFyIG5hbWVWYWx1ZVBhaXJTdHIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKTtcbiAgICAgIHZhciBuYW1lID0gcGFyc2VkLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJzZWQudmFsdWU7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5kZWNvZGVWYWx1ZXMgPyBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJzZXQtY29va2llLXBhcnNlciBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBkZWNvZGluZyBhIGNvb2tpZSB3aXRoIHZhbHVlICdcIiArIHZhbHVlICsgXCInLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXMgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXCIsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIGNvb2tpZSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgdmFyIHNpZGVzID0gcGFydC5zcGxpdChcIj1cIik7XG4gICAgICAgIHZhciBrZXkgPSBzaWRlcy5zaGlmdCgpLnRyaW1MZWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHZhbHVlMiA9IHNpZGVzLmpvaW4oXCI9XCIpO1xuICAgICAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIikge1xuICAgICAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUyKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWF4LWFnZVwiKSB7XG4gICAgICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlMiwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJodHRwb25seVwiKSB7XG4gICAgICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgICAgIGNvb2tpZS5zYW1lU2l0ZSA9IHZhbHVlMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29raWVba2V5XSA9IHZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU5hbWVWYWx1ZVBhaXIobmFtZVZhbHVlUGFpclN0cikge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAgIHZhciBuYW1lVmFsdWVBcnIgPSBuYW1lVmFsdWVQYWlyU3RyLnNwbGl0KFwiPVwiKTtcbiAgICAgIGlmIChuYW1lVmFsdWVBcnIubGVuZ3RoID4gMSkge1xuICAgICAgICBuYW1lID0gbmFtZVZhbHVlQXJyLnNoaWZ0KCk7XG4gICAgICAgIHZhbHVlID0gbmFtZVZhbHVlQXJyLmpvaW4oXCI9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyU3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2NoID0gaW5wdXQuaGVhZGVyc1tPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInNldC1jb29raWVcIjtcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgaWYgKCFzY2ggJiYgaW5wdXQuaGVhZGVycy5jb29raWUgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiV2FybmluZzogc2V0LWNvb2tpZS1wYXJzZXIgYXBwZWFycyB0byBoYXZlIGJlZW4gY2FsbGVkIG9uIGEgcmVxdWVzdCBvYmplY3QuIEl0IGlzIGRlc2lnbmVkIHRvIHBhcnNlIFNldC1Db29raWUgaGVhZGVycyBmcm9tIHJlc3BvbnNlcywgbm90IENvb2tpZSBoZWFkZXJzIGZyb20gcmVxdWVzdHMuIFNldCB0aGUgb3B0aW9uIHtzaWxlbnQ6IHRydWV9IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQgPSBzY2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb29raWVzID0ge307XG4gICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uKGNvb2tpZXMyLCBzdHIpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBjb29raWVzMltjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICAgICAgcmV0dXJuIGNvb2tpZXMyO1xuICAgICAgICB9LCBjb29raWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nMihjb29raWVzU3RyaW5nKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gY29va2llc1N0cmluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIGNoO1xuICAgICAgdmFyIGxhc3RDb21tYTtcbiAgICAgIHZhciBuZXh0U3RhcnQ7XG4gICAgICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuICAgICAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuICAgIG1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gICAgbW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbiAgICBtb2R1bGUuZXhwb3J0cy5zcGxpdENvb2tpZXNTdHJpbmcgPSBzcGxpdENvb2tpZXNTdHJpbmcyO1xuICB9XG59KTtcblxuLy8gc3JjL0hlYWRlcnMudHNcbnZhciBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIgPSBfX3RvRVNNKHJlcXVpcmVfc2V0X2Nvb2tpZSgpKTtcblxuLy8gc3JjL3V0aWxzL25vcm1hbGl6ZUhlYWRlck5hbWUudHNcbnZhciBIRUFERVJTX0lOVkFMSURfQ0hBUkFDVEVSUyA9IC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2k7XG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpIHtcbiAgaWYgKEhFQURFUlNfSU5WQUxJRF9DSEFSQUNURVJTLnRlc3QobmFtZSkgfHwgbmFtZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemVIZWFkZXJWYWx1ZS50c1xudmFyIGNoYXJDb2Rlc1RvUmVtb3ZlID0gW1xuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDEwKSxcbiAgU3RyaW5nLmZyb21DaGFyQ29kZSgxMyksXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoOSksXG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMzIpXG5dO1xudmFyIEhFQURFUl9WQUxVRV9SRU1PVkVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgYCheWyR7Y2hhckNvZGVzVG9SZW1vdmUuam9pbihcIlwiKX1dfCRbJHtjaGFyQ29kZXNUb1JlbW92ZS5qb2luKFwiXCIpfV0pYCxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBuZXh0VmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEhFQURFUl9WQUxVRV9SRU1PVkVfUkVHRVhQLCBcIlwiKTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2lzVmFsaWRIZWFkZXJOYW1lLnRzXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJhY3RlciA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJhY3RlciA+IDEyNyB8fCAhaXNUb2tlbihjaGFyYWN0ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gIVtcbiAgICAxMjcsXG4gICAgMzIsXG4gICAgXCIoXCIsXG4gICAgXCIpXCIsXG4gICAgXCI8XCIsXG4gICAgXCI+XCIsXG4gICAgXCJAXCIsXG4gICAgXCIsXCIsXG4gICAgXCI7XCIsXG4gICAgXCI6XCIsXG4gICAgXCJcXFxcXCIsXG4gICAgJ1wiJyxcbiAgICBcIi9cIixcbiAgICBcIltcIixcbiAgICBcIl1cIixcbiAgICBcIj9cIixcbiAgICBcIj1cIixcbiAgICBcIntcIixcbiAgICBcIn1cIlxuICBdLmluY2x1ZGVzKHZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2lzVmFsaWRIZWFkZXJWYWx1ZS50c1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlLnRyaW0oKSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJhY3RlciA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKFxuICAgICAgLy8gTlVMLlxuICAgICAgY2hhcmFjdGVyID09PSAwIHx8IC8vIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgICAgIGNoYXJhY3RlciA9PT0gMTAgfHwgY2hhcmFjdGVyID09PSAxM1xuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL0hlYWRlcnMudHNcbnZhciBOT1JNQUxJWkVEX0hFQURFUlMgPSBTeW1ib2woXCJub3JtYWxpemVkSGVhZGVyc1wiKTtcbnZhciBSQVdfSEVBREVSX05BTUVTID0gU3ltYm9sKFwicmF3SGVhZGVyTmFtZXNcIik7XG52YXIgSEVBREVSX1ZBTFVFX0RFTElNSVRFUiA9IFwiLCBcIjtcbnZhciBfYSwgX2I7XG52YXIgSGVhZGVycyA9IGNsYXNzIF9IZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgIC8vIE5vcm1hbGl6ZWQgaGVhZGVyIHtcIm5hbWVcIjpcImEsIGJcIn0gc3RvcmFnZS5cbiAgICB0aGlzW19hXSA9IHt9O1xuICAgIC8vIEtlZXBzIHRoZSBtYXBwaW5nIGJldHdlZW4gdGhlIHJhdyBoZWFkZXIgbmFtZVxuICAgIC8vIGFuZCB0aGUgbm9ybWFsaXplZCBoZWFkZXIgbmFtZSB0byBlYXNlIHRoZSBsb29rdXAuXG4gICAgdGhpc1tfYl0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChbXCJIZWFkZXJzXCIsIFwiSGVhZGVyc1BvbHlmaWxsXCJdLmluY2x1ZGVzKGluaXQ/LmNvbnN0cnVjdG9yLm5hbWUpIHx8IGluaXQgaW5zdGFuY2VvZiBfSGVhZGVycyB8fCB0eXBlb2YgZ2xvYmFsVGhpcy5IZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiICYmIGluaXQgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxIZWFkZXJzID0gaW5pdDtcbiAgICAgIGluaXRpYWxIZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgICAgaW5pdC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwZW5kKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKEhFQURFUl9WQUxVRV9ERUxJTUlURVIpIDogdmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5pdCkge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGluaXRbbmFtZV07XG4gICAgICAgIHRoaXMuYXBwZW5kKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKEhFQURFUl9WQUxVRV9ERUxJTUlURVIpIDogdmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBbKF9hID0gTk9STUFMSVpFRF9IRUFERVJTLCBfYiA9IFJBV19IRUFERVJfTkFNRVMsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAqa2V5cygpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgeWllbGQgbmFtZTtcbiAgICB9XG4gIH1cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9XG4gICplbnRyaWVzKCkge1xuICAgIGxldCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXModGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdKS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKVxuICAgICk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZEtleXMpIHtcbiAgICAgIGlmIChuYW1lID09PSBcInNldC1jb29raWVcIikge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuZ2V0U2V0Q29va2llKCkpIHtcbiAgICAgICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBbbmFtZSwgdGhpcy5nZXQobmFtZSldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gc3RhdGluZyB3aGV0aGVyIGEgYEhlYWRlcnNgIG9iamVjdCBjb250YWlucyBhIGNlcnRhaW4gaGVhZGVyLlxuICAgKi9cbiAgaGFzKG5hbWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGhlYWRlciBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW05PUk1BTElaRURfSEVBREVSU10uaGFzT3duUHJvcGVydHkobm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBgQnl0ZVN0cmluZ2Agc2VxdWVuY2Ugb2YgYWxsIHRoZSB2YWx1ZXMgb2YgYSBoZWFkZXIgd2l0aCBhIGdpdmVuIG5hbWUuXG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihgSW52YWxpZCBoZWFkZXIgbmFtZSBcIiR7bmFtZX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tOT1JNQUxJWkVEX0hFQURFUlNdW25vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSldID8/IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGhlYWRlciBpbnNpZGUgYSBgSGVhZGVyc2Agb2JqZWN0LCBvciBhZGRzIHRoZSBoZWFkZXIgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkgfHwgIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemVIZWFkZXJOYW1lKG5hbWUpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZUhlYWRlclZhbHVlKHZhbHVlKTtcbiAgICB0aGlzW05PUk1BTElaRURfSEVBREVSU11bbm9ybWFsaXplZE5hbWVdID0gbm9ybWFsaXplSGVhZGVyVmFsdWUobm9ybWFsaXplZFZhbHVlKTtcbiAgICB0aGlzW1JBV19IRUFERVJfTkFNRVNdLnNldChub3JtYWxpemVkTmFtZSwgbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgYSBuZXcgdmFsdWUgb250byBhbiBleGlzdGluZyBoZWFkZXIgaW5zaWRlIGEgYEhlYWRlcnNgIG9iamVjdCwgb3IgYWRkcyB0aGUgaGVhZGVyIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqL1xuICBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpIHx8ICFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplSGVhZGVyTmFtZShuYW1lKTtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVIZWFkZXJWYWx1ZSh2YWx1ZSk7XG4gICAgbGV0IHJlc29sdmVkVmFsdWUgPSB0aGlzLmhhcyhub3JtYWxpemVkTmFtZSkgPyBgJHt0aGlzLmdldChub3JtYWxpemVkTmFtZSl9LCAke25vcm1hbGl6ZWRWYWx1ZX1gIDogbm9ybWFsaXplZFZhbHVlO1xuICAgIHRoaXMuc2V0KG5hbWUsIHJlc29sdmVkVmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgaGVhZGVyIGZyb20gdGhlIGBIZWFkZXJzYCBvYmplY3QuXG4gICAqL1xuICBkZWxldGUobmFtZSkge1xuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgZGVsZXRlIHRoaXNbTk9STUFMSVpFRF9IRUFERVJTXVtub3JtYWxpemVkTmFtZV07XG4gICAgdGhpc1tSQVdfSEVBREVSX05BTUVTXS5kZWxldGUobm9ybWFsaXplZE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIGBIZWFkZXJzYCBvYmplY3QsXG4gICAqIGNhbGxpbmcgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGhlYWRlci5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXNcbiAgICogb2YgYWxsIFNldC1Db29raWUgaGVhZGVycyBhc3NvY2lhdGVkXG4gICAqIHdpdGggYSByZXNwb25zZVxuICAgKi9cbiAgZ2V0U2V0Q29va2llKCkge1xuICAgIGNvbnN0IHNldENvb2tpZUhlYWRlciA9IHRoaXMuZ2V0KFwic2V0LWNvb2tpZVwiKTtcbiAgICBpZiAoc2V0Q29va2llSGVhZGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChzZXRDb29raWVIZWFkZXIgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBbXCJcIl07XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZykoc2V0Q29va2llSGVhZGVyKTtcbiAgfVxufTtcblxuLy8gc3JjL2dldFJhd0hlYWRlcnMudHNcbmZ1bmN0aW9uIGdldFJhd0hlYWRlcnMoaGVhZGVycykge1xuICBjb25zdCByYXdIZWFkZXJzID0ge307XG4gIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBoZWFkZXJzLmVudHJpZXMoKSkge1xuICAgIHJhd0hlYWRlcnNbaGVhZGVyc1tSQVdfSEVBREVSX05BTUVTXS5nZXQobmFtZSldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJhd0hlYWRlcnM7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvaGVhZGVyc1RvTGlzdC50c1xuZnVuY3Rpb24gaGVhZGVyc1RvTGlzdChoZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNMaXN0ID0gW107XG4gIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIG5hbWUpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdmFsdWUuaW5jbHVkZXMoXCIsXCIpID8gdmFsdWUuc3BsaXQoXCIsXCIpLm1hcCgodmFsdWUyKSA9PiB2YWx1ZTIudHJpbSgpKSA6IHZhbHVlO1xuICAgIGhlYWRlcnNMaXN0LnB1c2goW25hbWUsIHJlc29sdmVkVmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzTGlzdDtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVycy9oZWFkZXJzVG9TdHJpbmcudHNcbmZ1bmN0aW9uIGhlYWRlcnNUb1N0cmluZyhoZWFkZXJzKSB7XG4gIGNvbnN0IGxpc3QgPSBoZWFkZXJzVG9MaXN0KGhlYWRlcnMpO1xuICBjb25zdCBsaW5lcyA9IGxpc3QubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlKTtcbiAgICByZXR1cm4gYCR7bmFtZX06ICR7dmFsdWVzLmpvaW4oXCIsIFwiKX1gO1xuICB9KTtcbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXHJcXG5cIik7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvaGVhZGVyc1RvT2JqZWN0LnRzXG52YXIgc2luZ2xlVmFsdWVIZWFkZXJzID0gW1widXNlci1hZ2VudFwiXTtcbmZ1bmN0aW9uIGhlYWRlcnNUb09iamVjdChoZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNPYmplY3QgPSB7fTtcbiAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IGlzTXVsdGlWYWx1ZSA9ICFzaW5nbGVWYWx1ZUhlYWRlcnMuaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKSAmJiB2YWx1ZS5pbmNsdWRlcyhcIixcIik7XG4gICAgaGVhZGVyc09iamVjdFtuYW1lXSA9IGlzTXVsdGlWYWx1ZSA/IHZhbHVlLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IHMudHJpbSgpKSA6IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnNPYmplY3Q7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvc3RyaW5nVG9IZWFkZXJzLnRzXG5mdW5jdGlvbiBzdHJpbmdUb0hlYWRlcnMoc3RyKSB7XG4gIGNvbnN0IGxpbmVzID0gc3RyLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gIHJldHVybiBsaW5lcy5yZWR1Y2UoKGhlYWRlcnMsIGxpbmUpID0+IHtcbiAgICBpZiAobGluZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoXCI6IFwiKTtcbiAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmpvaW4oXCI6IFwiKTtcbiAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sIG5ldyBIZWFkZXJzKCkpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2xpc3RUb0hlYWRlcnMudHNcbmZ1bmN0aW9uIGxpc3RUb0hlYWRlcnMobGlzdCkge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgbGlzdC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUyKSA9PiB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZTIpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvcmVkdWNlSGVhZGVyc09iamVjdC50c1xuZnVuY3Rpb24gcmVkdWNlSGVhZGVyc09iamVjdChoZWFkZXJzLCByZWR1Y2VyLCBpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgobmV4dEhlYWRlcnMsIG5hbWUpID0+IHtcbiAgICByZXR1cm4gcmVkdWNlcihuZXh0SGVhZGVycywgbmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gIH0sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvb2JqZWN0VG9IZWFkZXJzLnRzXG5mdW5jdGlvbiBvYmplY3RUb0hlYWRlcnMoaGVhZGVyc09iamVjdCkge1xuICByZXR1cm4gcmVkdWNlSGVhZGVyc09iamVjdChcbiAgICBoZWFkZXJzT2JqZWN0LFxuICAgIChoZWFkZXJzLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUyKSA9PiB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlMik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG4gICAgbmV3IEhlYWRlcnMoKVxuICApO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtZXJzL2ZsYXR0ZW5IZWFkZXJzTGlzdC50c1xuZnVuY3Rpb24gZmxhdHRlbkhlYWRlcnNMaXN0KGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubWFwKChbbmFtZSwgdmFsdWVzXSkgPT4ge1xuICAgIHJldHVybiBbbmFtZSwgW10uY29uY2F0KHZhbHVlcykuam9pbihcIiwgXCIpXTtcbiAgfSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1lcnMvZmxhdHRlbkhlYWRlcnNPYmplY3QudHNcbmZ1bmN0aW9uIGZsYXR0ZW5IZWFkZXJzT2JqZWN0KGhlYWRlcnNPYmplY3QpIHtcbiAgcmV0dXJuIHJlZHVjZUhlYWRlcnNPYmplY3QoXG4gICAgaGVhZGVyc09iamVjdCxcbiAgICAoaGVhZGVycywgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGhlYWRlcnNbbmFtZV0gPSBbXS5jb25jYXQodmFsdWUpLmpvaW4oXCIsIFwiKTtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cbmV4cG9ydCB7XG4gIEhlYWRlcnMsXG4gIGZsYXR0ZW5IZWFkZXJzTGlzdCxcbiAgZmxhdHRlbkhlYWRlcnNPYmplY3QsXG4gIGdldFJhd0hlYWRlcnMsXG4gIGhlYWRlcnNUb0xpc3QsXG4gIGhlYWRlcnNUb09iamVjdCxcbiAgaGVhZGVyc1RvU3RyaW5nLFxuICBsaXN0VG9IZWFkZXJzLFxuICBvYmplY3RUb0hlYWRlcnMsXG4gIHJlZHVjZUhlYWRlcnNPYmplY3QsXG4gIHN0cmluZ1RvSGVhZGVyc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19jb21tb25KUyIsImNiIiwibW9kIiwiX19yZXF1aXJlIiwiZXhwb3J0cyIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJnZXQiLCJlbnVtZXJhYmxlIiwiX190b0VTTSIsImlzTm9kZU1vZGUiLCJ0YXJnZXQiLCJfX2VzTW9kdWxlIiwidmFsdWUiLCJyZXF1aXJlX3NldF9jb29raWUiLCJtb2R1bGUiLCJkZWZhdWx0UGFyc2VPcHRpb25zIiwiZGVjb2RlVmFsdWVzIiwibWFwIiwic2lsZW50IiwiaXNOb25FbXB0eVN0cmluZyIsInN0ciIsInRyaW0iLCJwYXJzZVN0cmluZyIsInNldENvb2tpZVZhbHVlIiwib3B0aW9ucyIsInBhcnRzIiwic3BsaXQiLCJmaWx0ZXIiLCJuYW1lVmFsdWVQYWlyU3RyIiwic2hpZnQiLCJwYXJzZWQiLCJwYXJzZU5hbWVWYWx1ZVBhaXIiLCJuYW1lIiwiYXNzaWduIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImNvb2tpZSIsImZvckVhY2giLCJwYXJ0Iiwic2lkZXMiLCJ0cmltTGVmdCIsInRvTG93ZXJDYXNlIiwidmFsdWUyIiwiam9pbiIsImV4cGlyZXMiLCJEYXRlIiwibWF4QWdlIiwicGFyc2VJbnQiLCJzZWN1cmUiLCJodHRwT25seSIsInNhbWVTaXRlIiwibmFtZVZhbHVlQXJyIiwibGVuZ3RoIiwicGFyc2UiLCJpbnB1dCIsImhlYWRlcnMiLCJnZXRTZXRDb29raWUiLCJzY2giLCJrZXlzIiwiZmluZCIsIndhcm4iLCJBcnJheSIsImlzQXJyYXkiLCJjb29raWVzIiwicmVkdWNlIiwiY29va2llczIiLCJzcGxpdENvb2tpZXNTdHJpbmcyIiwiY29va2llc1N0cmluZyIsImNvb2tpZXNTdHJpbmdzIiwicG9zIiwic3RhcnQiLCJjaCIsImxhc3RDb21tYSIsIm5leHRTdGFydCIsImNvb2tpZXNTZXBhcmF0b3JGb3VuZCIsInNraXBXaGl0ZXNwYWNlIiwidGVzdCIsImNoYXJBdCIsIm5vdFNwZWNpYWxDaGFyIiwicHVzaCIsInN1YnN0cmluZyIsInNwbGl0Q29va2llc1N0cmluZyIsImltcG9ydF9zZXRfY29va2llX3BhcnNlciIsIkhFQURFUlNfSU5WQUxJRF9DSEFSQUNURVJTIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsIlR5cGVFcnJvciIsImNoYXJDb2Rlc1RvUmVtb3ZlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiSEVBREVSX1ZBTFVFX1JFTU9WRV9SRUdFWFAiLCJSZWdFeHAiLCJub3JtYWxpemVIZWFkZXJWYWx1ZSIsIm5leHRWYWx1ZSIsInJlcGxhY2UiLCJpc1ZhbGlkSGVhZGVyTmFtZSIsImkiLCJjaGFyYWN0ZXIiLCJjaGFyQ29kZUF0IiwiaXNUb2tlbiIsImluY2x1ZGVzIiwiaXNWYWxpZEhlYWRlclZhbHVlIiwiTk9STUFMSVpFRF9IRUFERVJTIiwiU3ltYm9sIiwiUkFXX0hFQURFUl9OQU1FUyIsIkhFQURFUl9WQUxVRV9ERUxJTUlURVIiLCJfYSIsIl9iIiwiSGVhZGVycyIsIl9IZWFkZXJzIiwiY29uc3RydWN0b3IiLCJpbml0IiwiTWFwIiwiZ2xvYmFsVGhpcyIsImluaXRpYWxIZWFkZXJzIiwiYXBwZW5kIiwiaXRlcmF0b3IiLCJlbnRyaWVzIiwidmFsdWVzIiwic29ydGVkS2V5cyIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJoYXMiLCJzZXQiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZWRWYWx1ZSIsInJlc29sdmVkVmFsdWUiLCJkZWxldGUiLCJjYWxsYmFjayIsInRoaXNBcmciLCJzZXRDb29raWVIZWFkZXIiLCJnZXRSYXdIZWFkZXJzIiwicmF3SGVhZGVycyIsImhlYWRlcnNUb0xpc3QiLCJoZWFkZXJzTGlzdCIsImhlYWRlcnNUb1N0cmluZyIsImxpc3QiLCJsaW5lcyIsImNvbmNhdCIsInNpbmdsZVZhbHVlSGVhZGVycyIsImhlYWRlcnNUb09iamVjdCIsImhlYWRlcnNPYmplY3QiLCJpc011bHRpVmFsdWUiLCJzIiwic3RyaW5nVG9IZWFkZXJzIiwibGluZSIsImxpc3RUb0hlYWRlcnMiLCJyZWR1Y2VIZWFkZXJzT2JqZWN0IiwicmVkdWNlciIsImluaXRpYWxTdGF0ZSIsIm5leHRIZWFkZXJzIiwib2JqZWN0VG9IZWFkZXJzIiwiQm9vbGVhbiIsImZsYXR0ZW5IZWFkZXJzTGlzdCIsImZsYXR0ZW5IZWFkZXJzT2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/headers-polyfill/lib/index.mjs\n");

/***/ })

};
;